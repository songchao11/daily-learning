# Shell

### 一、shell入门

#### 1.1 为什么要是用shell脚本

使用脚本编程语言的好处是，它们多半运行在比编译醒语言还高的层次，能够轻易处理文件与目录之类的对象。缺点是它们的效率通常不如编译型语言。

shell脚本具有以下特点：

简单性

​		shell是一个高级语言，可以简洁的表达复杂的操作

可移植性

​		shell在各Unix系统之间通用，使用POSIX所定义的功能

开发容易

​		可在短时间内完成一个功能强大又好用的脚本

#### 1.2 一个简单的脚本

比如我现在想知道系统上有多少人登录？

```
who
```

who命令可以告诉你现在系统有谁登录

在大型的多用户系统上，可能展示的列表就很长，此时查看用户个数就很麻烦，因此我们可以使用wc命令来完成计数

```
who | wc -l          计算用户个数
```

wc -l 计算行数  wc -w 计算字数  wc -c 字节数 ...

| （管道）符号可以在两程序之间建立管道(pipeline),上面who的输出成了wc的输入。

接下来就是将上面的命令转化为一个独立的命令。方法是将上命令输入一个文件中，然后使用chmod命令为该文件设置执行的权限，如下所示：

```
$ cat > first          建立文件，使用cat复制终端的输入
who | wc -l            程序内容
ctrl+D                 end of file
$ chmod +x first       让文件拥有执行权限
$ ./first              执行测试
```

shell脚本的开头通常是 #! /bin/sh 开头

#### 1.3 基本的I/O重定向

标准输入/输出可能是软件设计原理里最重要的概念了。这个概念就是：程序应该有数据的来源端、数据的目的端以及报告问题的地方，它们分别被称为标准输入、标准输出以及标准错误输出。程序不必知道也不关心它的输入输出背后是什么设备：是磁盘上的文件、终端还是另一个执行中的程序。当程序启动时，可以预期的是，标准输入输出都已打开，且已准备好供其使用。

许多UNIX程序都遵循这一设计原则。默认情况下，它们会读取标准输入、写入标准输出，并将错误传递到标准错误输出。这类程序通常叫做过滤器(filter)。默认的标准输入输出以及错误输出都是终端，这点可以通过cat程序得知：

```
$ cat           未指定任何参数，读取标准输入，写入标准输出
now is the time  由用户输入
now is the time  有cat返回
```

你可能想要知道，是谁替执行中的程序初始化标准输入、输出及错误输出的呢？答案就是在你登录时，UNIX便将默认的标准输入、输出及错误输出安排成你的终端。I/O重定向就是你通过与终端交互，或是在shell脚本里设置，重新安排从哪里输入或输出到哪里。

#### 1.4 重定向与管道

shell提供了数种语法，用来改变默认IO的来源端与目的端，如下：

①以 < 改变标准输入

program < file  可将program的标准输入修改为file

```
tr -d '\n' < test.txt    #删除test.txt 文件中每行后面的回车
```

②以  > 改变标准输出

program > file 可将program的标准输出修改为file

```
tr -d '\n' < test.txt > test2.txt #将上面处理后的文本内容输出到test2.txt中
```

注意: >重定向符在目的文件不存在时，会创建一个。若目的文件已存在，将会被覆盖。

③以 >> 附加到文件

program >> file 可将program的标准输出附加到file的尾部(不会覆盖掉文件)

④以 | 建立管道

program1 | program2可将program1的标准输出修改为program2的标准输入

#### 1.5 特殊文件

UNIX系统提供了两个对shell编程特别有用的特殊文件：/dev/null和/dev/tty

①/dev/null

就是大家所熟知的位桶。传送到此文件的数据都会被系统丢掉。也就是说，当程序将数据写到此文件时，会认为它已经完成了写入数据的操作，但实际什么都没做。

②/dev/tty

当程序打开此文件时，UNIX会自动将它重定向到一个终端

#### 1.6访问shell脚本的参数

所谓的位置参数指的就是shell脚本的命令行参数。在shell函数里，它们同时也可以是函数的参数。各参数都由整数来命名。基于历史原因，当它超过9，就要用大括号把数字框起来

```
echo first arg is $1
echo tenth arg is ${10}
```

eg: vim finduser.sh 内容如下

```
#! /bin/bash
who | grep $1
```

执行: ./finduser.sh zhangsan

#### 1.7 简单的执行跟踪

程序难免会出错，想知道你的程序正在做什么，有个好方法就是把执行跟踪的功能打开。这会使得shell显示每个被执行到的命令，并在前面加上"+"。

打开的方式：sh -x ./finduser.sh

或者可以在脚本里使用 set -x打开执行跟踪，用 set +x关闭